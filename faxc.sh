#!/bin/bash

# Fax Compiler Driver Script
# Compiles Fax source files to executable binaries

set -e

# Configuration
FAX_VERSION="0.2.0"
FAX_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_DIR="${FAX_DIR}/build"
TEMP_DIR="${BUILD_DIR}/temp"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Help message
usage() {
    cat << EOF
Fax Compiler v${FAX_VERSION}

Usage: faxc [options] <source.fax>

Options:
    -h, --help          Show this help message
    -v, --version       Show version
    -o <file>           Output file (default: a.out)
    -O <level>          Optimization level (0, 1, 2, 3)
    --emit-llvm         Emit LLVM IR only (.ll file)
    --emit-asm          Emit assembly (.s file)
    --emit-object       Emit object file (.o file)
    -g                  Generate debug info
    --gc                Enable FGC (Fax Garbage Collector)
    --no-stdlib         Don't link standard library
    --verbose           Verbose output

Examples:
    faxc hello.fax                  # Compile to a.out
    faxc hello.fax -o hello         # Compile to hello
    faxc hello.fax --emit-llvm      # Generate hello.ll
    faxc hello.fax -O2              # Compile with optimizations

EOF
}

# Parse arguments
SOURCE_FILE=""
OUTPUT_FILE="a.out"
OPT_LEVEL="0"
EMIT_LLVM=false
EMIT_ASM=false
EMIT_OBJECT=false
DEBUG=false
USE_GC=false
USE_STDLIB=true
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -v|--version)
            echo "Fax Compiler v${FAX_VERSION}"
            exit 0
            ;;
        -o)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -O)
            OPT_LEVEL="$2"
            shift 2
            ;;
        --emit-llvm)
            EMIT_LLVM=true
            shift
            ;;
        --emit-asm)
            EMIT_ASM=true
            shift
            ;;
        --emit-object)
            EMIT_OBJECT=true
            shift
            ;;
        -g)
            DEBUG=true
            shift
            ;;
        --gc)
            USE_GC=true
            shift
            ;;
        --no-stdlib)
            USE_STDLIB=false
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        -*)
            echo -e "${RED}Error: Unknown option $1${NC}"
            usage
            exit 1
            ;;
        *)
            if [[ -z "$SOURCE_FILE" ]]; then
                SOURCE_FILE="$1"
            else
                echo -e "${RED}Error: Multiple source files not supported yet${NC}"
                exit 1
            fi
            shift
            ;;
    esac
done

# Check source file
if [[ -z "$SOURCE_FILE" ]]; then
    echo -e "${RED}Error: No source file specified${NC}"
    usage
    exit 1
fi

if [[ ! -f "$SOURCE_FILE" ]]; then
    echo -e "${RED}Error: Source file not found: $SOURCE_FILE${NC}"
    exit 1
fi

# Create build directories
mkdir -p "${BUILD_DIR}"
mkdir -p "${TEMP_DIR}"

# Base name
BASE_NAME=$(basename "$SOURCE_FILE" .fax)
LL_FILE="${TEMP_DIR}/${BASE_NAME}.ll"
S_FILE="${TEMP_DIR}/${BASE_NAME}.s"
O_FILE="${TEMP_DIR}/${BASE_NAME}.o"

if [[ "$VERBOSE" == true ]]; then
    echo -e "${BLUE}Fax Compiler v${FAX_VERSION}${NC}"
    echo "Source: ${SOURCE_FILE}"
    echo "Output: ${OUTPUT_FILE}"
    echo "Build directory: ${BUILD_DIR}"
fi

# Check for required tools
check_tool() {
    if ! command -v "$1" &> /dev/null; then
        echo -e "${RED}Error: $1 is required but not installed${NC}"
        exit 1
    fi
}

check_tool clang

# Run Lean compiler to generate LLVM IR
echo -e "${YELLOW}Compiling ${SOURCE_FILE}...${NC}"

# For now, use a placeholder command
# In real implementation, this would call the Lean-compiled Fax compiler
cat > "${LL_FILE}" << 'EOF'
; Fax Language IR
; Generated by Fax Compiler
target triple = "x86_64-unknown-linux-gnu"
target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"

declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)

@.str_int = private constant [4 x i8] c"%d\0A\00"

; Standard library
define void @println(i32 %x) {
entry:
  %fmt = getelementptr [4 x i8], [4 x i8]* @.str_int, i64 0, i64 0
  call i32 (i8*, ...) @printf(i8* %fmt, i32 %x)
  ret void
}

; Main function placeholder
define i32 @main() {
entry:
  call void @println(i32 42)
  ret i32 0
}
EOF

if [[ "$EMIT_LLVM" == true ]]; then
    cp "${LL_FILE}" "${BASE_NAME}.ll"
    echo -e "${GREEN}Generated: ${BASE_NAME}.ll${NC}"
    exit 0
fi

# Generate assembly from LLVM IR
echo -e "${YELLOW}Generating assembly...${NC}"
if [[ "$VERBOSE" == true ]]; then
    llc "${LL_FILE}" -o "${S_FILE}" -O="${OPT_LEVEL}" || {
        echo -e "${RED}Error: Failed to generate assembly${NC}"
        exit 1
    }
else
    llc "${LL_FILE}" -o "${S_FILE}" -O="${OPT_LEVEL}" 2>/dev/null || {
        echo -e "${RED}Error: Failed to generate assembly${NC}"
        exit 1
    }
fi

if [[ "$EMIT_ASM" == true ]]; then
    cp "${S_FILE}" "${BASE_NAME}.s"
    echo -e "${GREEN}Generated: ${BASE_NAME}.s${NC}"
    exit 0
fi

# Compile to object file
echo -e "${YELLOW}Generating object file...${NC}"
clang -c "${S_FILE}" -o "${O_FILE}" || {
    echo -e "${RED}Error: Failed to generate object file${NC}"
    exit 1
}

if [[ "$EMIT_OBJECT" == true ]]; then
    cp "${O_FILE}" "${BASE_NAME}.o"
    echo -e "${GREEN}Generated: ${BASE_NAME}.o${NC}"
    exit 0
fi

# Link executable
LINK_FLAGS=""
if [[ "$DEBUG" == true ]]; then
    LINK_FLAGS="${LINK_FLAGS} -g"
fi

if [[ "$USE_GC" == true ]]; then
    # Add FGC runtime library
    LINK_FLAGS="${LINK_FLAGS} -lfgc"
fi

if [[ "$USE_STDLIB" == true ]]; then
    # Add standard C library
    LINK_FLAGS="${LINK_FLAGS} -lc"
fi

echo -e "${YELLOW}Linking executable...${NC}"
clang "${O_FILE}" -o "${OUTPUT_FILE}" ${LINK_FLAGS} || {
    echo -e "${RED}Error: Failed to link executable${NC}"
    exit 1
}

# Success
echo -e "${GREEN}Successfully compiled: ${OUTPUT_FILE}${NC}"

# Cleanup if not verbose
if [[ "$VERBOSE" == false ]]; then
    rm -rf "${TEMP_DIR}"
fi

exit 0
