/-
Codegen with Protobuf input/output - Microservice Architecture
Accepts Module in protobuf format and generates LLVM IR
Follows same pattern as Lexer.Proto and Parser.Proto
-/

import Compiler.Codegen
import Compiler.Codegen.Expr
import Compiler.Codegen.Stmt
import Compiler.Codegen.IR
import Compiler.Codegen.Types
import Compiler.Codegen.Proto.Converters
import Compiler.Proto
import Compiler.Proto.Messages
import Compiler.Proto.Services
import Compiler.Runtime

namespace Compiler.Codegen.Proto

open Proto
open Proto.Messages
open Proto.Services
open Compiler.Codegen.Proto.Converters

-- Codegen state for microservice
def CodegenState := List (String × String)

def freshReg (counter : Nat) : String :=
  s!"%{counter}"

-- ============================================================================
-- Protobuf Input/Output Functions (Following Lexer.Proto and Parser.Proto pattern)
-- ============================================================================

-- Generate LLVM IR from protobuf Module
def generateFromProtobuf (module : Proto.Messages.Module) : String :=
  let opts : CodegenOptions := {
    targetTriple := "x86_64-unknown-linux-gnu",
    optLevel := 2,
    emitDebug := false
  }
  generateModuleIR module opts

-- Generate LLVM IR from protobuf Module with custom options
def generateFromProtobufWithOptions (module : Proto.Messages.Module) (opts : CodegenOptions) : String :=
  generateModuleIR module opts

-- Generate LLVM IR from serialized protobuf bytes
def generateFromBytes (data : ByteArray) : Except String String := do
  let module ← match Proto.deserializeModule data with
    | some m => Except.ok m
    | none => Except.error "Failed to deserialize Module"
  return generateFromProtobuf module

-- Generate LLVM IR and return as protobuf CodegenResponse
def generateWithResponse (module : Proto.Messages.Module) (options : CodegenOptions) : CodegenResponse :=
  try
    let ir := generateModuleIR module options
    { llvmIR := some ir
      objectFile := none
      error := none
    }
  catch e =>
    { llvmIR := none
      objectFile := none
      error := some (.internalError (toString e))
    }

-- Convert Lean AST Module to LLVM IR and return protobuf response
def generateFromAST (module : AST.Module) (opts : CodegenOptions) : CodegenResponse :=
  let protoModule := AST.Module.toProto module
  generateWithResponse protoModule opts

-- ============================================================================
-- Internal Code Generation
-- ============================================================================

-- Generate complete module IR
def generateModuleIR (m : Module) (opts : CodegenOptions) : String :=
  let header := buildModuleHeader opts
  let typeDefs := generateTypeDefinitions m.decls
  let funcs := generateFunctions m.decls
  let stdlib := generateStdlibRuntime
  
  header ++ "\n" ++ typeDefs ++ "\n" ++ stdlib ++ "\n" ++ funcs

-- Build module header with runtime declarations
def buildModuleHeader (opts : CodegenOptions) : String :=
  s!"; Fax Language IR
; Generated by Fax Compiler Codegen Service
target triple = \"{opts.targetTriple}\"
target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"

; External declarations
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)
declare i8* @malloc(i64)
declare void @free(i8*)

; String format constants
@.str_int = private constant [4 x i8] c\"%d\\0A\\00\"
@.str_str = private constant [4 x i8] c\"%s\\0A\\00\"
"

-- Generate standard library runtime
def generateStdlibRuntime : String :=
  "; Standard Library Runtime

; Print integer with newline
define void @println(i32 %x) {
entry:
  %fmt = getelementptr [4 x i8], [4 x i8]* @.str_int, i64 0, i64 0
  call i32 (i8*, ...) @printf(i8* %fmt, i32 %x)
  ret void
}

; Print string with newline
define void @println_str(i8* %s) {
entry:
  call i32 @puts(i8* %s)
  ret void
}

; Print integer without newline
define void @print(i32 %x) {
entry:
  %fmt = getelementptr [4 x i8], [4 x i8]* @.str_int, i64 0, i64 0
  call i32 (i8*, ...) @printf(i8* %fmt, i32 %x)
  ret void
}

"

-- Generate type definitions from declarations
def generateTypeDefinitions (decls : List Decl) : String :=
  decls.foldl (fun acc decl =>
    match decl with
    | .struct name fields =>
      let fieldTypes := fields.map (fun (_, t) => protoTypeToLLVM t) |> String.intercalate ", "
      acc ++ s!"%{name} = type {{ {fieldTypes} }}\n"
    | _ => acc
  ) ""

-- Generate all functions
def generateFunctions (decls : List Decl) : String :=
  decls.foldl (fun acc decl =>
    match decl with
    | .func name params ret body =>
      acc ++ generateFunction name params ret body
    | _ => acc
  ) ""

-- Generate single function
def generateFunction (name : String) (params : List (String × Ty)) (ret : Ty) (body : Expr) : String :=
  let retTy := protoTypeToLLVM ret
  let paramStr := params.map (fun (n, t) => s!"{protoTypeToLLVM t} %{n}") |> String.intercalate ", "
  
  let funcHeader := s!"\ndefine {retTy} @{name}({paramStr}) {{\nentry:\n"
  
  -- Generate body
  let (bodyCode, resultReg, _, _) := generateExpr body [] 1
  
  -- Return statement
  let retCode := match ret with
  | .primitive .unit => "  ret void\n"
  | _ => s!"  ret {retTy} {resultReg}\n"
  
  funcHeader ++ bodyCode ++ "\n" ++ retCode ++ "}\n"

-- Convert proto type to LLVM type string
def protoTypeToLLVM (ty : Ty) : String :=
  match ty with
  | .primitive .unit => "void"
  | .primitive .i8 => "i8"
  | .primitive .i16 => "i16"
  | .primitive .i32 => "i32"
  | .primitive .i64 => "i64"
  | .primitive .u8 => "i8"
  | .primitive .u16 => "i16"
  | .primitive .u32 => "i32"
  | .primitive .u64 => "i64"
  | .primitive .f32 => "float"
  | .primitive .f64 => "double"
  | .primitive .bool => "i1"
  | .primitive .char => "i8"
  | .primitive .string => "i8*"
  | .primitive .inferred => "i32"
  | .array elem size => s!"[{size} x {protoTypeToLLVM elem}]"
  | .tuple elems => s!"{{{elems.map protoTypeToLLVM |> String.intercalate ", "}}}"
  | .structTy name _ => s!"%{name}"
  | .enumTy name _ => s!"%{name}"
  | .fun args ret => s!"{protoTypeToLLVM ret} ({args.map protoTypeToLLVM |> String.intercalate ", "})*"
  | .named n => s!"%{n}"

-- Get expression type
def exprType (e : Expr) : Ty :=
  match e with
  | .lit (.int _) => .primitive .i32
  | .lit (.float _) => .primitive .f64
  | .lit (.bool _) => .primitive .bool
  | .lit (.char _) => .primitive .char
  | .lit (.string _) => .primitive .string
  | _ => .primitive .i32

-- Generate expression code (recursive)
partial def generateExpr (expr : Expr) (state : CodegenState) (counter : Nat) : String × String × CodegenState × Nat :=
  match expr with
  | .lit l =>
    let (code, reg) := emitLiteral l
    (code, reg, state, counter)
  
  | .var n =>
    match state.find? (fun (name, _) => name == n) with
    | some (_, reg) => ("", reg, state, counter)
    | none => ("", s!"@{n}", state, counter)
  
  | .unary op operand =>
    let (code1, reg1, state1, c1) := generateExpr operand state (counter + 1)
    let resultReg := s!"%{c1}"
    let opCode := emitUnaryOp op reg1 resultReg
    (code1 ++ "\n" ++ opCode, resultReg, state1, c1 + 1)
  
  | .binary op left right =>
    let ty := protoTypeToLLVM (exprType left)
    let (code1, reg1, state1, c1) := generateExpr left state (counter + 1)
    let (code2, reg2, state2, c2) := generateExpr right state1 (c1 + 1)
    let resultReg := s!"%{c2}"
    let opCode := emitBinaryOp op ty reg1 reg2 resultReg
    (code1 ++ "\n" ++ code2 ++ "\n" ++ opCode, resultReg, state2, c2 + 1)
  
  | .call fnName args =>
    let (argsCode, argsRegs, finalState, finalCounter) :=
      args.foldl (fun (accCode, accRegs, accState, accCounter) arg =>
        let (c, r, newState, newCounter) := generateExpr arg accState accCounter
        (accCode ++ c, accRegs ++ [(protoTypeToLLVM (exprType arg), r)], newState, newCounter)
      ) ("", [], state, counter)
    
    let resultReg := s!"%{finalCounter}"
    let argsStr := argsRegs.map (fun (ty, reg) => s!"{ty} {reg}") |> String.intercalate ", "
    let callCode := s!"  {resultReg} = call i32 @{fnName}({argsStr})"
    (argsCode ++ "\n" ++ callCode, resultReg, finalState, finalCounter + 1)
  
  | .ifExpr cond thenExpr elseExpr =>
    let (code1, condReg, state1, c1) := generateExpr cond state (counter + 1)
    let (code2, thenReg, state2, c2) := generateExpr thenExpr state1 (c1 + 1)
    let (code3, elseReg, state3, c3) := generateExpr elseExpr state2 (c2 + 1)
    
    let ty := protoTypeToLLVM (exprType thenExpr)
    let resultReg := s!"%{c3}"
    let thenLabel := s!"if_then_{c3}"
    let elseLabel := s!"if_else_{c3}"
    let endLabel := s!"if_end_{c3}"
    
    let branchCode := s!"
  br i1 {condReg}, label %{thenLabel}, label %{elseLabel}

{thenLabel}:
{code2}
  br label %{endLabel}

{elseLabel}:
{code3}
  br label %{endLabel}

{endLabel}:
  {resultReg} = phi {ty} [{thenReg}, %{thenLabel}], [{elseReg}, %{elseLabel}]"
    
    (code1 ++ branchCode, resultReg, state3, c3 + 1)
  
  | .block stmts expr =>
    -- Generate statements
    let (stmtsCode, finalState, finalCounter) :=
      stmts.foldl (fun (accCode, accState, accCounter) stmt =>
        let (code, newState, newCounter) := generateStmt stmt accState accCounter
        (accCode ++ code, newState, newCounter)
      ) ("", state, counter)
    
    -- Generate final expression
    let (exprCode, resultReg, state', c') := generateExpr expr finalState finalCounter
    (stmtsCode ++ exprCode, resultReg, state', c')
  
  | .letExpr pat value body =>
    -- Generate value
    let (valCode, valReg, state1, c1) := generateExpr value state (counter + 1)
    
    -- Extract variable name from pattern
    let varName := match pat with
    | .var n => n
    | _ => s!"_let_{counter}"
    
    -- Allocate and store
    let ptrReg := s!"%{c1}"
    let storeCode := s!"
  {ptrReg} = alloca i32
  store i32 {valReg}, i32* {ptrReg}"
    
    let state2 := (varName, ptrReg) :: state1
    
    -- Generate body
    let (bodyCode, bodyReg, state3, c2) := generateExpr body state2 (c1 + 1)
    
    (valCode ++ storeCode ++ bodyCode, bodyReg, state3, c2)
  
  | _ => ("", "i32 0", state, counter)

-- Generate statement code
def generateStmt (stmt : Stmt) (state : CodegenState) (counter : Nat) : String × CodegenState × Nat :=
  match stmt with
  | .decl pat value =>
    let (valCode, valReg, state1, c1) := generateExpr value state (counter + 1)
    
    let varName := match pat with
    | .var n => n
    | _ => s!"_var_{counter}"
    
    let ptrReg := s!"%{c1}"
    let storeCode := s!"
  {ptrReg} = alloca i32
  store i32 {valReg}, i32* {ptrReg}"
    
    let state2 := (varName, ptrReg) :: state1
    (valCode ++ storeCode, state2, c1 + 1)
  
  | .assign lhs rhs =>
    match lhs with
    | .var n =>
      match state.find? (fun (name, _) => name == n) with
      | some (_, ptrReg) =>
        let (rhsCode, rhsReg, state1, c1) := generateExpr rhs state (counter + 1)
        let storeCode := s!"
  store i32 {rhsReg}, i32* {ptrReg}"
        (rhsCode ++ storeCode, state1, c1)
      | none =>
        let (rhsCode, rhsReg, state1, c1) := generateExpr rhs state (counter + 1)
        let storeCode := s!"
  store i32 {rhsReg}, i32* @{n}"
        (rhsCode ++ storeCode, state1, c1)
    | _ => ("", state, counter)
  
  | .exprStmt e =>
    let (code, _, state1, c1) := generateExpr e state counter
    (code, state1, c1)
  
  | .return e =>
    let (code, reg, state1, c1) := generateExpr e state counter
    let retCode := s!"
  ret i32 {reg}"
    (code ++ retCode, state1, c1)
  
  | .break => ("  br label %break", state, counter)
  | .continue => ("  br label %continue", state, counter)

-- Emit literal
def emitLiteral (lit : Literal) : String × String :=
  match lit with
  | .int val => ("", s!"i32 {val}")
  | .float val => ("", s!"double {val}")
  | .bool true => ("", "i1 1")
  | .bool false => ("", "i1 0")
  | .string str =>
    let constName := s!".str_{str.length}_{str.hash}"
    let strLen := str.length + 1
    let code := s!"{constName} = private constant [{strLen} x i8] c\"{str}\\00\""
    let reg := s!"i8* getelementptr ([{strLen} x i8], [{strLen} x i8]* {constName}, i64 0, i64 0)"
    (code, reg)
  | .char c => ("", s!"i8 {c.toNat}")

-- Emit unary operation
def emitUnaryOp (op : UnaryOp) (operandReg : String) (resultReg : String) : String :=
  match op with
  | .neg => s!"  {resultReg} = sub i32 0, {operandReg}"
  | .not => s!"  {resultReg} = xor i1 {operandReg}, 1"
  | .bitnot => s!"  {resultReg} = xor i32 {operandReg}, -1"

-- Emit binary operation
def emitBinaryOp (op : BinaryOp) (ty : String) (leftReg : String) (rightReg : String) (resultReg : String) : String :=
  match op with
  | .add => s!"  {resultReg} = add {ty} {leftReg}, {rightReg}"
  | .sub => s!"  {resultReg} = sub {ty} {leftReg}, {rightReg}"
  | .mul => s!"  {resultReg} = mul {ty} {leftReg}, {rightReg}"
  | .div => s!"  {resultReg} = sdiv {ty} {leftReg}, {rightReg}"
  | .mod => s!"  {resultReg} = srem {ty} {leftReg}, {rightReg}"
  | .and => s!"  {resultReg} = and i1 {leftReg}, {rightReg}"
  | .or => s!"  {resultReg} = or i1 {leftReg}, {rightReg}"
  | .eq =>
    if ty == "i1" then
      s!"  {resultReg} = icmp eq i1 {leftReg}, {rightReg}"
    else
      s!"  {resultReg} = icmp eq {ty} {leftReg}, {rightReg}"
  | .ne =>
    if ty == "i1" then
      s!"  {resultReg} = icmp ne i1 {leftReg}, {rightReg}"
    else
      s!"  {resultReg} = icmp ne {ty} {leftReg}, {rightReg}"
  | .lt => s!"  {resultReg} = icmp slt {ty} {leftReg}, {rightReg}"
  | .le => s!"  {resultReg} = icmp sle {ty} {leftReg}, {rightReg}"
  | .gt => s!"  {resultReg} = icmp sgt {ty} {leftReg}, {rightReg}"
  | .ge => s!"  {resultReg} = icmp sge {ty} {leftReg}, {rightReg}"
  | .shl => s!"  {resultReg} = shl {ty} {leftReg}, {rightReg}"
  | .shr => s!"  {resultReg} = ashr {ty} {leftReg}, {rightReg}"
  | .band => s!"  {resultReg} = and {ty} {leftReg}, {rightReg}"
  | .bor => s!"  {resultReg} = or {ty} {leftReg}, {rightReg}"
  | .bxor => s!"  {resultReg} = xor {ty} {leftReg}, {rightReg}"

-- ============================================================================
-- Service Handler (For gRPC Integration)
-- ============================================================================

-- Codegen service implementation for gRPC
def handleCodegenService (request : CodegenRequest) : IO CodegenResponse := do
  try
    -- Validate request
    if request.ast.decls.isEmpty then
      return {
        llvmIR := none,
        objectFile := none,
        error := some (.invalidRequest "Empty AST module")
      }
    
    -- Generate IR with FGC if available
    let ir := generateModuleIR request.ast request.options
    
    return {
      llvmIR := some ir,
      objectFile := none,
      error := none
    }
  catch e =>
    return {
      llvmIR := none,
      objectFile := none,
      error := some (.internalError (toString e))
    }

-- Compile with full microservice pipeline using FGC
def compileWithMicroservices (source : String) (useFGC : Bool := true) : IO (Except String String) := do
  try
    -- Create runtime with FGC if requested
    let pool ← if useFGC then
      Runtime.createRuntime (256 * 1024 * 1024) 4
    else
      pure { heapSize := 0, numThreads := 1 } -- Dummy pool
    
    -- Step 1: Lexing service
    let lexReq : LexRequest := { source := source, filename := "input.fax" }
    let lexResp ← handleLexService lexReq
    
    match lexResp.tokens with
    | none =>
      if useFGC then Runtime.shutdownRuntime pool
      return Except.error s!"Lexing failed: {lexResp.error}"
    | some tokens =>
      -- Step 2: Parsing service
      let parseReq : ParseRequest := { tokens := tokens }
      let parseResp ← handleParseService parseReq
      
      match parseResp.ast with
      | none =>
        if useFGC then Runtime.shutdownRuntime pool
        return Except.error s!"Parsing failed: {parseResp.error}"
      | some ast =>
        -- Step 3: Codegen service
        let codegenReq : CodegenRequest := {
          ast := ast,
          options := {
            targetTriple := "x86_64-unknown-linux-gnu",
            optLevel := 2,
            emitDebug := false
          }
        }
        
        let codegenResp ← handleCodegenService codegenReq
        
        -- Cleanup
        if useFGC then Runtime.shutdownRuntime pool
        
        match codegenResp.llvmIR with
        | none =>
          match codegenResp.error with
          | some err => return Except.error s!"Codegen failed: {err}"
          | none => return Except.error "Codegen failed: Unknown error"
        | some ir =>
          return Except.ok ir
  catch e =>
    return Except.error s!"Compilation failed: {e}"

-- Placeholder service handlers (would connect to actual gRPC services)
def handleLexService (req : LexRequest) : IO LexResponse := do
  -- In real implementation, this would call the Lexer gRPC service
  -- For now, return empty response
  return { tokens := none, error := some .unavailable }

def handleParseService (req : ParseRequest) : IO ParseResponse := do
  -- In real implementation, this would call the Parser gRPC service
  return { ast := none, error := some .unavailable }

end Compiler.Codegen.Proto
