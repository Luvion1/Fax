import Compiler.Codegen.Types
import Compiler.Codegen.Expr
import Compiler.Codegen.Stmt

namespace Compiler.Codegen.IR

open Compiler.AST

-- Counter for unique global names
private globalNameCounter : IO.Ref Nat := unsafePerformIO (IO.mkRef 0)

private def unsafePerformIO {α} (io : IO α) : α :=
  match io.run {} with
  | EStateM.Result.ok a _ => a
  | _ => panic! "unsafePerformIO failed"

-- Generate unique global name
def freshGlobalName (prefix : String) : String :=
  let counter := globalNameCounter.modifyGet (fun n => (n, n + 1))
  s!"{prefix}.{counter}"

-- Build module header with runtime declarations
def buildHeader : String :=
  "; Fax Language IR
; Generated by Fax Compiler
target triple = \"x86_64-unknown-linux-gnu\"
target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"

; External declarations
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)
declare i32 @putchar(i32)
declare i8* @malloc(i64)
declare void @free(i8*)
declare void @llvm.memset.p0i8.i64(i8*, i8, i64, i1)

; String format constants
@.str_int = private constant [4 x i8] c\"%d\\0A\\00\"
@.str_str = private constant [4 x i8] c\"%s\\0A\\00\"
@.str_char = private constant [3 x i8] c\"%c\\00\"
@.str_true = private constant [5 x i8] c\"true\\00\"
@.str_false = private constant [6 x i8] c\"false\\00\"
\n"

-- Build parameter list for function
def buildParams (params : List (String × Ty)) : String :=
  params.map (fun (name, ty) => 
    s!"{Types.toLLVMType ty} %{name}"
  ) |> String.intercalate ", "

-- Build function with complete body generation
def buildFunc (name : String) (params : List (String × Ty)) (ret : Ty) (body : Expr) : String :=
  let retTy := Types.toLLVMType ret
  let paramStr := buildParams params
  let funcDecl := s!"define {retTy} @{name}({paramStr}) {{\nentry:\n"
  
  -- Generate body code
  let (bodyCode, resultReg, _, _) := Expr.generate body [] 1
  
  -- Add return
  let retCode := match ret with
  | .unit => "  ret void\n"
  | _ => s!"  ret {retTy} {resultReg}\n"
  
  funcDecl ++ bodyCode ++ "\n" ++ retCode ++ "}\n\n"

-- Build variable declarations (for global variables)
def buildGlobal (name : String) (ty : Ty) (init : Option Lit) : String :=
  let llvmTy := Types.toLLVMType ty
  let initVal := match init with
  | some (.intLit n) => s!"{n}"
  | some (.boolLit b) => if b then "1" else "0"
  | some (.charLit c) => s!"{c.toNat}"
  | _ => "0"
  s!"@{name} = global {llvmTy} {initVal}\n"

-- Build struct type definition
def buildStructType (name : String) (fields : List (String × Ty)) : String :=
  let fieldTypes := fields.map (fun (_, ty) => Types.toLLVMType ty) |> String.intercalate ", "
  s!"%{name} = type {{ {fieldTypes} }}\n"

-- Build complete module
def buildModule (decls : List Decl) : String :=
  let header := buildHeader
  
  -- First pass: collect type definitions (structs and enums)
  let typeDefs := decls.foldl (fun acc d => match d with
    | .structDecl _ name fields => 
      acc ++ buildStructType name fields
    | _ => acc
  ) ""
  
  -- Second pass: collect global variable declarations
  -- (Currently no global vars in Fax, but placeholder)
  let globals := ""
  
  -- Third pass: generate function definitions
  let funcs := decls.foldl (fun acc d => match d with
    | .funDecl _ name params ret body =>
      acc ++ buildFunc name params ret body
    | _ => acc
  ) ""
  
  header ++ typeDefs ++ globals ++ funcs

-- Find main function name from declarations
def findMainFunction (decls : List Decl) : Option String :=
  decls.findSome? (fun d => match d with
    | .funDecl _ name _ _ _ => 
      if name == "main" then some name
      else if name == "main.fax" then some name
      else none
    | _ => none)

-- Entry point wrapper for main function
def buildEntryPoint (decls : List Decl) (initCode : String) : String :=
  match findMainFunction decls with
  | some mainName =>
    s!"define i32 @main(i32 %argc, i8** %argv) {{
entry:
{initCode}
  %result = call i32 @{mainName}()
  ret i32 %result
}}

"
  | none =>
    -- No main function found, create default
    s!"define i32 @main(i32 %argc, i8** %argv) {{
entry:
  ret i32 0
}}

"

-- Build complete module with entry point
def buildModuleWithEntry (decls : List Decl) : String :=
  let baseModule := buildModule decls
  let entryPoint := buildEntryPoint decls ""
  baseModule ++ entryPoint

end Compiler.Codegen.IR
